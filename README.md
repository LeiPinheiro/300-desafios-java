# Resolvendo 300 desafios em java üêß
> [!WARNING]  
> **Planegei esses desafios e categorias com a IA DeepSeek, ou seja, alguns desafios podem estar muito fora da curva e at√© errados, caso eu veja que esse √© o caso, vou s√≥ pular o desafio.**

Este repos√≠torio √© um desafio pessoal onde documento 300 desafios de diferentes dificuldades resolvidos usando a linguagem Java. Resolvi fazer isso enquanto estudo sobre a linguagem para melhorar minha l√≥gica e ao mesmo tempo melhorar meu entendimento em java.

Os desafios s√£o separados em dificuldades (f√°cil, m√©dia e dif√≠cil), e dentro dessas dificuldades existem "categorias" de assuntos importantes para aprender.
**Cada dificuldade tem 100 desafios diferentes, 10 desafios s√£o separados por categorias. Com o passar dos desafios mais dif√≠ceis eles ficam.**

## üìã Categorias
- **N√≠vel F√°cil**: Arrays & Strings, Loops & Condicionais, OOP B√°sica, Recurs√£o, Linked Lists, Matem√°tica, Tratamento de Erros, Collections Framework, Manipula√ß√£o de Arquivos, Threads.
- **N√≠vel M√©dio**: √Årvores & Grafos, Algoritmos de Ordena√ß√£o, Programa√ß√£o Din√¢mica, Design Patterns, Threads & Concorr√™ncia, Estruturas de Dados Avan√ßadas, Algoritmos de Grafos, Problemas de Otimiza√ß√£o, Sistemas Distribu√≠dos, Machine Learning B√°sico.
- **N√≠vel Dif√≠cil**: Algoritmos Avan√ßados, Programa√ß√£o Din√¢mica Avan√ßada, Grafos Avan√ßados, Estruturas de Dados Complexas, Concorr√™ncia Avan√ßada, Sistemas Distribu√≠dos, Machine Learning, Compiladores & Interpretadores, Seguran√ßa, Projetos Complexos.

## üìå Como funciona?
- Todos os dias (ou nem sempre), resolvo alguns desafios em Java.
- Cada desafio resolvido √© armazenado em uma pasta correspondente ao nome do desafio.
- O c√≥digo de cada desafio √© salvo com um nome descritivo.
- Um arquivo README.md acompanha cada arquivo, explicando os desafios e solu√ß√µes.

## üìÇ Estrutura do reposit√≥rio
Tem bastante pasta, ent√£o deixei s√≥ uma parte do reposit√≥rio todo.
```plaintext
üìÇ300-desafios-java/
‚îú‚îÄ‚îÄ üìÇdificuldade-f√°cil/
‚îÇ   ‚îú‚îÄ‚îÄ üìÇarrays&strings/
‚îÇ     ‚îú‚îÄ‚îÄ üìÇdesafio-001/
‚îÇ       ‚îú‚îÄ‚îÄ desafio_001.java
‚îÇ       ‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ README.md
```

## üöÄ Objetivos
- ‚úîÔ∏è Melhorar minha l√≥gica de programa√ß√£o
- ‚úîÔ∏è Aprender e refor√ßar conceitos de Java
- ‚úîÔ∏è Criar uma rotina de estudos consistente

# üóíÔ∏è Lista de desafios

Esta √© uma lista de **300 desafios de programa√ß√£o** em Java, organizados por n√≠vel de dificuldade (f√°cil, m√©dio e dif√≠cil). Cada desafio vem com uma dica para ajudar no come√ßo.

---

## **N√≠vel F√°cil (100 Desafios)**

### **1. Arrays & Strings**
1. **Soma de Dois N√∫meros**: Receba dois n√∫meros e retorne a soma.  
   **Dica**: Use operador `+`.

2. **Maior Elemento em um Array**: Encontre o maior n√∫mero em um array.  
   **Dica**: Use um loop e uma vari√°vel tempor√°ria.

3. **Contar Vogais**: Conte o n√∫mero de vogais em uma string.  
   **Dica**: Use `String.charAt()` e um loop.

4. **Inverter String**: Inverta uma string sem usar bibliotecas externas.  
   **Dica**: Use um loop reverso.

5. **Verificar Pal√≠ndromo**: Verifique se uma string √© um pal√≠ndromo.  
   **Dica**: Compare caracteres do in√≠cio e fim.

6. **Remover Duplicatas**: Remova elementos duplicados de um array.  
   **Dica**: Use `HashSet`.

7. **Soma de Elementos Pares**: Some apenas os n√∫meros pares de um array.  
   **Dica**: Use `%` para verificar paridade.

8. **Encontrar √çndice de um Elemento**: Retorne o √≠ndice de um elemento em um array.  
   **Dica**: Use um loop e `if`.

9. **Concatenar Arrays**: Concatene dois arrays em um.  
   **Dica**: Use `System.arraycopy()`.

10. **Contar Caracteres**: Conte quantas vezes um caractere aparece em uma string.  
    **Dica**: Use `String.charAt()` e um loop.

---

### **2. Loops & Condicionais**
11. **Fibonacci**: Imprima a sequ√™ncia Fibonacci at√© N termos.  
    **Dica**: Use um loop e vari√°veis auxiliares.

12. **Fatorial**: Calcule o fatorial de um n√∫mero.  
    **Dica**: Use recurs√£o ou loop.

13. **Tabuada**: Imprima a tabuada de um n√∫mero.  
    **Dica**: Use um loop `for`.

14. **N√∫meros Primos**: Verifique se um n√∫mero √© primo.  
    **Dica**: Use um loop at√© `Math.sqrt(n)`.

15. **IMC**: Calcule o √çndice de Massa Corporal.  
    **Dica**: Use `Scanner` para entrada.

16. **Soma de D√≠gitos**: Some os d√≠gitos de um n√∫mero.  
    **Dica**: Use `%` e `/`.

17. **Divisores de um N√∫mero**: Liste todos os divisores de um n√∫mero.  
    **Dica**: Use um loop at√© `n`.

18. **M√∫ltiplos de 3 e 5**: Some todos os m√∫ltiplos de 3 e 5 abaixo de N.  
    **Dica**: Use `%` e `||`.

19. **Padr√£o de N√∫meros**: Imprima um padr√£o de n√∫meros (ex: pir√¢mide).  
    **Dica**: Use loops aninhados.

20. **Convers√£o de Temperatura**: Converta Celsius para Fahrenheit.  
    **Dica**: Use f√≥rmula `(C * 9/5) + 32`.

---

### **3. OOP B√°sica**
21. **Classe `Pessoa`**: Crie uma classe `Pessoa` com atributos `nome` e `idade`.  
    **Dica**: Use getters e setters.

22. **Heran√ßa**: Crie uma classe `Animal` e subclasses `Cachorro` e `Gato`.  
    **Dica**: Use `extends`.

23. **M√©todo Est√°tico**: Crie um m√©todo est√°tico para calcular a √°rea de um c√≠rculo.  
    **Dica**: Use `Math.PI`.

24. **Encapsulamento**: Crie uma classe `ContaBancaria` com saldo privado.  
    **Dica**: Use `private` e m√©todos p√∫blicos.

25. **Construtor**: Crie uma classe `Carro` com construtor para `marca` e `modelo`.  
    **Dica**: Use `this`.

26. **Sobrecarga de M√©todos**: Crie m√©todos com o mesmo nome mas par√¢metros diferentes.  
    **Dica**: Use diferentes assinaturas.

27. **Interface `Forma`**: Crie uma interface com m√©todo `calcularArea()`.  
    **Dica**: Implemente em classes como `C√≠rculo` e `Quadrado`.

28. **Polimorfismo**: Use uma superclasse para referenciar objetos de subclasses.  
    **Dica**: Use `Animal animal = new Cachorro()`.

29. **Singleton**: Implemente uma classe Singleton.  
    **Dica**: Use construtor privado e m√©todo est√°tico.

30. **Enum**: Crie um enum `DiaDaSemana` com m√©todos.  
    **Dica**: Use `enum` e `switch`.

---

### **4. Recurs√£o**
31. **Soma Recursiva**: Some os n√∫meros de 1 a N.  
    **Dica**: Use recurs√£o com caso base `n == 1`.

32. **Fatorial Recursivo**: Calcule o fatorial de um n√∫mero.  
    **Dica**: Use recurs√£o com caso base `n == 0`.

33. **Fibonacci Recursivo**: Implemente a sequ√™ncia Fibonacci.  
    **Dica**: Use recurs√£o com casos base `n == 0` e `n == 1`.

34. **Pot√™ncia Recursiva**: Calcule `a^b` usando recurs√£o.  
    **Dica**: Use `a * potencia(a, b-1)`.

35. **Contagem Regressiva**: Imprima n√∫meros de N a 1.  
    **Dica**: Use recurs√£o com caso base `n == 0`.

36. **Soma de D√≠gitos Recursiva**: Some os d√≠gitos de um n√∫mero.  
    **Dica**: Use `n % 10 + somaDigitos(n / 10)`.

37. **Inverter String Recursivo**: Inverta uma string.  
    **Dica**: Use `charAt()` e recurs√£o.

38. **MDC Recursivo**: Calcule o m√°ximo divisor comum.  
    **Dica**: Use o algoritmo de Euclides.

39. **Torre de Hanoi**: Resolva o problema com recurs√£o.  
    **Dica**: Mova discos entre torres.

40. **Busca Bin√°ria Recursiva**: Implemente busca bin√°ria.  
    **Dica**: Divida o array ao meio.

---

### **5. Listas Ligadas**
41. **Inserir no In√≠cio**: Insira um n√≥ no in√≠cio de uma lista ligada.  
    **Dica**: Atualize o `head`.

42. **Inserir no Fim**: Insira um n√≥ no fim de uma lista ligada.  
    **Dica**: Percorra at√© o √∫ltimo n√≥.

43. **Remover do In√≠cio**: Remova o primeiro n√≥.  
    **Dica**: Atualize o `head`.

44. **Remover do Fim**: Remova o √∫ltimo n√≥.  
    **Dica**: Percorra at√© o pen√∫ltimo n√≥.

45. **Buscar Elemento**: Verifique se um valor est√° na lista.  
    **Dica**: Percorra a lista.

46. **Tamanho da Lista**: Calcule o n√∫mero de n√≥s.  
    **Dica**: Use um contador.

47. **Inverter Lista**: Inverta a ordem dos n√≥s.  
    **Dica**: Use tr√™s ponteiros.

48. **Remover Duplicatas**: Remova n√≥s duplicados.  
    **Dica**: Use `HashSet`.

49. **Unir Listas**: Concatene duas listas ligadas.  
    **Dica**: Anexe a segunda lista ao fim da primeira.

50. **N-√©simo N√≥**: Retorne o n√≥ na posi√ß√£o N.  
    **Dica**: Percorra at√© a posi√ß√£o.

---

### **6. Matem√°tica**
51. **M√©dia de N√∫meros**: Calcule a m√©dia de um array.  
    **Dica**: Some e divida pelo tamanho.

52. **MDC**: Calcule o m√°ximo divisor comum.  
    **Dica**: Use o algoritmo de Euclides.

53. **MMC**: Calcule o m√≠nimo m√∫ltiplo comum.  
    **Dica**: Use `MDC(a, b) * MMC(a, b) = a * b`.

54. **N√∫meros Primos at√© N**: Liste todos os primos at√© N.  
    **Dica**: Use o crivo de Erat√≥stenes.

55. **Pot√™ncia de 2**: Verifique se um n√∫mero √© pot√™ncia de 2.  
    **Dica**: Use `(n & (n - 1)) == 0`.

56. **Fatorial de N√∫meros Grandes**: Calcule fatorial para n√∫meros grandes.  
    **Dica**: Use `BigInteger`.

57. **Soma de S√©ries**: Calcule a soma de uma s√©rie (ex: 1 + 1/2 + 1/3 + ...).  
    **Dica**: Use um loop.

58. **Convers√£o de Base**: Converta um n√∫mero decimal para bin√°rio.  
    **Dica**: Use divis√µes sucessivas.

59. **N√∫meros Amigos**: Verifique se dois n√∫meros s√£o amigos.  
    **Dica**: Compare a soma dos divisores.

60. **N√∫meros Perfeitos**: Verifique se um n√∫mero √© perfeito.  
    **Dica**: Compare a soma dos divisores com o n√∫mero.

---

### **7. Tratamento de Erros**
61. **Divis√£o por Zero**: Trate exce√ß√£o de divis√£o por zero.  
    **Dica**: Use `try-catch`.

62. **Convers√£o de String para Inteiro**: Trate exce√ß√£o de convers√£o inv√°lida.  
    **Dica**: Use `Integer.parseInt()`.

63. **Leitura de Arquivo**: Trate exce√ß√£o de arquivo n√£o encontrado.  
    **Dica**: Use `FileReader` e `try-catch`.

64. **Valida√ß√£o de Entrada**: Valide se a entrada √© um n√∫mero.  
    **Dica**: Use `Scanner.hasNextInt()`.

65. **Exce√ß√£o Personalizada**: Crie uma exce√ß√£o personalizada.  
    **Dica**: Estenda `Exception`.

66. **Finally**: Use `finally` para liberar recursos.  
    **Dica**: Feche `Scanner` ou `FileReader`.

67. **Multi-catch**: Capture m√∫ltiplas exce√ß√µes em um bloco.  
    **Dica**: Use `catch (Exception1 | Exception2 e)`.

68. **Lan√ßamento de Exce√ß√£o**: Lance uma exce√ß√£o manualmente.  
    **Dica**: Use `throw new Exception()`.

69. **Exce√ß√£o em M√©todos**: Declare exce√ß√µes em m√©todos.  
    **Dica**: Use `throws`.

70. **Recupera√ß√£o de Erros**: Recupere-se de uma exce√ß√£o e continue.  
    **Dica**: Use `try-catch` em um loop.

---

### **8. Collections Framework**
71. **ArrayList**: Adicione e remova elementos de um `ArrayList`.  
    **Dica**: Use `add()` e `remove()`.

72. **HashSet**: Verifique se um elemento est√° em um `HashSet`.  
    **Dica**: Use `contains()`.

73. **HashMap**: Conte a frequ√™ncia de palavras em um texto.  
    **Dica**: Use `put()` e `get()`.

74. **Ordena√ß√£o de Lista**: Ordene uma lista de strings.  
    **Dica**: Use `Collections.sort()`.

75. **Itera√ß√£o com Iterator**: Itere sobre uma lista com `Iterator`.  
    **Dica**: Use `hasNext()` e `next()`.

76. **LinkedList**: Implemente uma fila com `LinkedList`.  
    **Dica**: Use `addLast()` e `removeFirst()`.

77. **TreeSet**: Armazene elementos ordenados em um `TreeSet`.  
    **Dica**: Use `add()`.

78. **PriorityQueue**: Implemente uma fila de prioridade.  
    **Dica**: Use `Comparator`.

79. **Stream API**: Filtre n√∫meros pares de uma lista.  
    **Dica**: Use `filter()` e `collect()`.

80. **ConcurrentHashMap**: Use `ConcurrentHashMap` para thread-safety.  
    **Dica**: Use `putIfAbsent()`.

---

### **9. Manipula√ß√£o de Arquivos**
81. **Leitura de Arquivo**: Leia um arquivo linha por linha.  
    **Dica**: Use `BufferedReader`.

82. **Escrita em Arquivo**: Escreva texto em um arquivo.  
    **Dica**: Use `FileWriter`.

83. **Copiar Arquivo**: Copie o conte√∫do de um arquivo para outro.  
    **Dica**: Use `FileInputStream` e `FileOutputStream`.

84. **Contar Linhas**: Conte o n√∫mero de linhas em um arquivo.  
    **Dica**: Use `BufferedReader`.

85. **Buscar Palavra**: Verifique se uma palavra est√° em um arquivo.  
    **Dica**: Use `contains()`.

86. **Serializa√ß√£o**: Serialize um objeto para um arquivo.  
    **Dica**: Use `ObjectOutputStream`.

87. **Desserializa√ß√£o**: Desserialize um objeto de um arquivo.  
    **Dica**: Use `ObjectInputStream`.

88. **Compactar Arquivo**: Compacte um arquivo usando ZIP.  
    **Dica**: Use `ZipOutputStream`.

89. **Descompactar Arquivo**: Descompacte um arquivo ZIP.  
    **Dica**: Use `ZipInputStream`.

90. **Manipula√ß√£o de Diret√≥rios**: Liste arquivos em um diret√≥rio.  
    **Dica**: Use `File.listFiles()`.

---

### **10. Threads**
91. **Thread Simples**: Crie uma thread que imprime n√∫meros.  
    **Dica**: Estenda `Thread` ou implemente `Runnable`.

92. **Sincroniza√ß√£o**: Sincronize threads para evitar race conditions.  
    **Dica**: Use `synchronized`.

93. **Wait e Notify**: Implemente produtor-consumidor com `wait()` e `notify()`.  
    **Dica**: Use um buffer compartilhado.

94. **Thread Pool**: Use `ExecutorService` para gerenciar threads.  
    **Dica**: Use `Executors.newFixedThreadPool()`.

95. **Callable e Future**: Retorne um valor de uma thread.  
    **Dica**: Use `Callable` e `Future`.

96. **Deadlock**: Simule um deadlock com duas threads.  
    **Dica**: Use bloqueios m√∫tuos.

97. **Thread Local**: Use `ThreadLocal` para vari√°veis locais.  
    **Dica**: Armazene dados espec√≠ficos por thread.

98. **TimerTask**: Agende uma tarefa com `Timer`.  
    **Dica**: Use `Timer.schedule()`.

99. **Atomic Variables**: Use `AtomicInteger` para opera√ß√µes at√¥micas.  
    **Dica**: Evite sincroniza√ß√£o manual.

100. **ForkJoinPool**: Divida uma tarefa em subtarefas.  
     **Dica**: Use `RecursiveTask`.

---

## **N√≠vel M√©dio (100 Desafios)**

### **1. √Årvores & Grafos**
1. **Altura de uma √Årvore Bin√°ria**: Calcule a altura de uma √°rvore.  
   **Dica**: Use recurs√£o e `Math.max()`.

2. **Verificar BST**: Verifique se uma √°rvore √© uma BST v√°lida.  
   **Dica**: Use limites m√≠nimos e m√°ximos.

3. **Percurso em Ordem**: Implemente o percurso em ordem (in-order).  
   **Dica**: Use recurs√£o.

4. **Percurso em N√≠vel (BFS)**: Implemente o percurso em n√≠vel.  
   **Dica**: Use uma fila (`Queue`).

5. **Caminho Mais Curto em Grafo**: Implemente BFS para encontrar o caminho mais curto.  
   **Dica**: Use `Queue` e marque n√≥s visitados.

6. **Detectar Ciclos em Grafo**: Verifique se um grafo tem ciclos.  
   **Dica**: Use DFS e marque n√≥s visitados.

7. **Topological Sort**: Ordene n√≥s de um grafo direcionado ac√≠clico (DAG).  
   **Dica**: Use DFS e uma pilha.

8. **√Årvore de Menor Custo (MST)**: Implemente o algoritmo de Kruskal.  
   **Dica**: Use `PriorityQueue` e Union-Find.

9. **Caminho Mais Longo em DAG**: Encontre o caminho mais longo em um DAG.  
   **Dica**: Use topological sort e relaxamento.

10. **Componentes Conectados**: Conte o n√∫mero de componentes conectados em um grafo.  
    **Dica**: Use DFS ou BFS.

---

### **2. Algoritmos de Ordena√ß√£o**
11. **Merge Sort**: Implemente o Merge Sort.  
    **Dica**: Divida o array e combine com arrays tempor√°rios.

12. **Quick Sort**: Implemente o Quick Sort.  
    **Dica**: Use parti√ß√£o e recurs√£o.

13. **Heap Sort**: Implemente o Heap Sort.  
    **Dica**: Use uma heap m√°xima.

14. **Counting Sort**: Implemente o Counting Sort.  
    **Dica**: Use um array de contadores.

15. **Radix Sort**: Implemente o Radix Sort.  
    **Dica**: Use buckets para cada d√≠gito.

16. **Bucket Sort**: Implemente o Bucket Sort.  
    **Dica**: Divida o array em intervalos.

17. **Ordena√ß√£o de Objetos**: Ordene uma lista de objetos por um atributo.  
    **Dica**: Use `Comparator`.

18. **Ordena√ß√£o Est√°vel**: Implemente uma ordena√ß√£o est√°vel.  
    **Dica**: Use Merge Sort.

19. **Ordena√ß√£o em Listas Ligadas**: Ordene uma lista ligada.  
    **Dica**: Use Merge Sort.

20. **Ordena√ß√£o Externa**: Ordene um arquivo grande que n√£o cabe na mem√≥ria.  
    **Dica**: Use divis√£o e intercala√ß√£o.

---

### **3. Programa√ß√£o Din√¢mica**
21. **Fibonacci com Memoiza√ß√£o**: Calcule Fibonacci usando memoiza√ß√£o.  
    **Dica**: Use um array para armazenar resultados.

22. **Problema da Mochila**: Resolva o problema da mochila.  
    **Dica**: Use uma matriz de estados.

23. **Maior Subsequ√™ncia Comum (LCS)**: Encontre a maior subsequ√™ncia comum entre duas strings.  
    **Dica**: Use uma matriz de estados.

24. **Maior Subarray Cont√≠guo**: Encontre o subarray com a maior soma.  
    **Dica**: Use o algoritmo de Kadane.

25. **Troco M√≠nimo**: Encontre o n√∫mero m√≠nimo de moedas para um valor.  
    **Dica**: Use programa√ß√£o din√¢mica.

26. **Caminhos em Grade**: Conte o n√∫mero de caminhos em uma grade.  
    **Dica**: Use uma matriz de estados.

27. **Quebra de Palavras**: Verifique se uma string pode ser quebrada em palavras v√°lidas.  
    **Dica**: Use memoiza√ß√£o.

28. **Maior Subsequ√™ncia Crescente**: Encontre a maior subsequ√™ncia crescente.  
    **Dica**: Use uma matriz de estados.

29. **Problema do Corte de Hastes**: Maximize o valor de cortes em uma haste.  
    **Dica**: Use programa√ß√£o din√¢mica.

30. **Edit Distance**: Calcule a dist√¢ncia de edi√ß√£o entre duas strings.  
    **Dica**: Use uma matriz de estados.

---

### **4. Design Patterns**
31. **Singleton**: Implemente uma classe Singleton thread-safe.  
    **Dica**: Use construtor privado e m√©todo est√°tico.

32. **Factory Method**: Implemente o padr√£o Factory Method.  
    **Dica**: Crie uma interface e classes concretas.

33. **Observer**: Implemente o padr√£o Observer.  
    **Dica**: Use `Subject` e `Observer`.

34. **Decorator**: Implemente o padr√£o Decorator.  
    **Dica**: Adicione funcionalidades dinamicamente.

35. **Strategy**: Implemente o padr√£o Strategy.  
    **Dica**: Use interfaces para algoritmos intercambi√°veis.

36. **Adapter**: Implemente o padr√£o Adapter.  
    **Dica**: Adapte uma interface para outra.

37. **Proxy**: Implemente o padr√£o Proxy.  
    **Dica**: Controle o acesso a um objeto.

38. **Command**: Implemente o padr√£o Command.  
    **Dica**: Encapsule comandos em objetos.

39. **Template Method**: Implemente o padr√£o Template Method.  
    **Dica**: Defina esqueletos de algoritmos.

40. **State**: Implemente o padr√£o State.  
    **Dica**: Mude o comportamento com base no estado.

---

### **5. Threads & Concorr√™ncia**
41. **Produtor-Consumidor**: Implemente o problema do produtor-consumidor.  
    **Dica**: Use `wait()` e `notify()`.

42. **Leitores-Escritores**: Implemente o problema dos leitores-escritores.  
    **Dica**: Use `ReentrantReadWriteLock`.

43. **Thread Pool**: Crie um thread pool personalizado.  
    **Dica**: Use `BlockingQueue`.

44. **Callable e Future**: Retorne um valor de uma thread.  
    **Dica**: Use `Callable` e `Future`.

45. **Sincroniza√ß√£o com Sem√°foros**: Use sem√°foros para controlar acesso.  
    **Dica**: Use `Semaphore`.

46. **Barreira de Threads**: Sincronize threads em uma barreira.  
    **Dica**: Use `CyclicBarrier`.

47. **Exchanger**: Troque dados entre threads.  
    **Dica**: Use `Exchanger`.

48. **StampedLock**: Use `StampedLock` para otimizar leituras.  
    **Dica**: Use `tryOptimisticRead()`.

49. **ForkJoinPool**: Divida uma tarefa em subtarefas.  
    **Dica**: Use `RecursiveTask`.

50. **Atomic Variables**: Use vari√°veis at√¥micas para opera√ß√µes seguras.  
    **Dica**: Use `AtomicInteger`.

---

### **6. Estruturas de Dados Avan√ßadas**
51. **√Årvore AVL**: Implemente inser√ß√£o e rota√ß√µes.  
    **Dica**: Mantenha o balanceamento.

52. **√Årvore Rubro-Negra**: Implemente inser√ß√£o e balanceamento.  
    **Dica**: Use regras de colora√ß√£o.

53. **Trie**: Implemente uma Trie para armazenar palavras.  
    **Dica**: Use n√≥s com filhos.

54. **Segment Tree**: Implemente uma √°rvore de segmentos.  
    **Dica**: Use divis√£o e conquista.

55. **Fenwick Tree**: Implemente uma √°rvore de Fenwick.  
    **Dica**: Use opera√ß√µes de bits.

56. **Union-Find**: Implemente Union-Find com compress√£o de caminho.  
    **Dica**: Use arrays para pais e ranks.

57. **Deque**: Implemente uma fila de duas pontas.  
    **Dica**: Use `ArrayDeque`.

58. **Bloom Filter**: Implemente um filtro de Bloom.  
    **Dica**: Use m√∫ltiplas fun√ß√µes de hash.

59. **Skip List**: Implemente uma skip list.  
    **Dica**: Use n√≠veis de ponteiros.

60. **Graph Adjacency List**: Implemente um grafo usando lista de adjac√™ncia.  
    **Dica**: Use `HashMap` e `LinkedList`.

---

### **7. Algoritmos de Grafos**
61. **Dijkstra**: Implemente o algoritmo de Dijkstra.  
    **Dica**: Use `PriorityQueue`.

62. **Bellman-Ford**: Implemente o algoritmo de Bellman-Ford.  
    **Dica**: Relaxe arestas repetidamente.

63. **Floyd-Warshall**: Implemente o algoritmo de Floyd-Warshall.  
    **Dica**: Use uma matriz de dist√¢ncias.

64. **Kruskal**: Implemente o algoritmo de Kruskal.  
    **Dica**: Use Union-Find.

65. **Prim**: Implemente o algoritmo de Prim.  
    **Dica**: Use `PriorityQueue`.

66. **Tarjan**: Implemente o algoritmo de Tarjan para componentes fortemente conectados.  
    **Dica**: Use DFS e pilha.

67. **Kosaraju**: Implemente o algoritmo de Kosaraju.  
    **Dica**: Use DFS duas vezes.

68. **Eulerian Path**: Verifique se um grafo tem um caminho euleriano.  
    **Dica**: Conte graus dos n√≥s.

69. **Hamiltonian Path**: Verifique se um grafo tem um caminho hamiltoniano.  
    **Dica**: Use backtracking.

70. **Bipartite Graph**: Verifique se um grafo √© bipartido.  
    **Dica**: Use colora√ß√£o com BFS.

---

### **8. Problemas de Otimiza√ß√£o**
71. **Knapsack 0/1**: Resolva o problema da mochila 0/1.  
    **Dica**: Use programa√ß√£o din√¢mica.

72. **Problema do Caixeiro Viajante (TSP)**: Resolva o TSP com backtracking.  
    **Dica**: Use recurs√£o e marque n√≥s visitados.

73. **Aloca√ß√£o de Recursos**: Otimize a aloca√ß√£o de recursos.  
    **Dica**: Use programa√ß√£o linear.

74. **Agendamento de Tarefas**: Agende tarefas para minimizar o tempo total.  
    **Dica**: Use algoritmos gananciosos.

75. **Problema do Corte de Hastes**: Maximize o valor de cortes.  
    **Dica**: Use programa√ß√£o din√¢mica.

76. **Problema do Troco**: Encontre o n√∫mero m√≠nimo de moedas.  
    **Dica**: Use programa√ß√£o din√¢mica.

77. **Problema da Mochila Fracion√°ria**: Resolva o problema da mochila fracion√°ria.  
    **Dica**: Use algoritmos gananciosos.

78. **Problema do Escalonamento de Intervalos**: Escalone intervalos sem sobreposi√ß√£o.  
    **Dica**: Use algoritmos gananciosos.

79. **Problema 

## üèÜ Progresso
1. ### N√≠vel Dific√≠l:
   - üìÖ Desafio 01 - ‚úÖ

